(function(exports) {
	
	var noop = function() {};
	
	exports.createEmitter = function() {
		if (typeof window === 'undefined') {
			var events = require("events"); // using " so the resolver doesnt get confused

			return function() {
				return new events.EventEmitter();
			};
		}		
		return function() {
			var that = {};
			
			var listeners = {};
			
			that.on = function(name, listener) {
				listeners[name] = listeners[name] || [];
				listeners[name].push(listener);
				
				return that;			
			};
			that.once = function(name, listener) {
				var onevent = function() {
					that.removeListener(name, onevent);
					listener.apply(null, arguments);
				};
				
				return that.on(name, onevent);
			};
			that.removeListener = function(name, listener) {
				if (!listeners[name]) {
					return that;
				}
				var index = listeners[name].indexOf(listener);
				
				if (index === -1) {
					return that;
				}

				listeners[name].splice(index,1);

				if (!listeners[name].length) {
					delete listeners[name];
				}
				
				return that;			
			};
			that.removeAllListeners = function(name) {
				delete listeners[name];
			};
			that.emit = function(name) {
				if (!listeners[name]) {
					return;
				}
				var args = Array.prototype.slice.call(arguments, 1);
				var ls = listeners[name].slice();
				
				for (var i = 0; i < ls.length; i++) {
					ls[i].apply(null, args);
				}
			};
			
			return that;
		};
	}();
	
	// functional patterns below
	
	exports.fork = function(a,b) {
		return function(err, value) {
			if (err) {
				a(err);
				return;
			}
			b(value);
		};
	};
	
	exports.step = function(funcs, onerror) {
		var counter = 0;
		var completed = 0;
		var pointer = 0;
		var ended = false;
		var state = {};
		var values = null;
		var complete = false;

		var check = function() {
			return complete && completed >= counter;
		};
		var next = function(err, value) {
			if (err && !ended) {
				ended = true;
				(onerror || noop).apply(state, [err]);
				return;
			}
			if (ended || (counter && !check())) {
				return;
			}

			var fn = funcs[pointer++];
			var args = (fn.length === 1 ? [next] : [value, next]);

			counter = completed = 0;
			values = [];
			complete = false;
			fn.apply(state, pointer < funcs.length ? args : [value]);
			complete = true;

			if (counter && check()) {
				next(null, values);
			}
		};
		next.parallel = function() {
			var index = counter++;

			if (complete) {
				throw new Error('next.parallel must not be called async');
			}
			return function(err, value) {
				completed++;
				values[index] = value;
				next(err, values);
			};
		};

		next();
	};
	
	exports.memoizer = function(fn) {
		var cache = {};
		
		var stringify = function(obj) {
			var type = typeof obj;

			if (type !== 'object') {
				return type + ': ' + obj;
			}
			var keys = [];
			
			for (var i in obj) {
				keys.push(stringify(obj[i]));
			}
			return keys.sort().join('\n');
		};
		
		return function() {
			var key = '';
			
			for (var i = 0; i < arguments.length; i++) {
				key += stringify(arguments[i]) + '\n';
			}
			
			cache[key] = cache[key] || fn.apply(null, arguments);

			return cache[key];
		};
	};
	
	exports.curry = function(fn) {
		var args = Array.prototype.slice.call(arguments, 1);

		return function() {
			return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
		};
	};
	
	exports.once = function(fn) {
		var once = true;

		return function() {
			if (once) {
				once = false;
				(fn || noop).apply(null, arguments);
				return true;
			}
			return false;
		};
	};
	
	exports.future = function() {
		var that = {};
		var stack = [];
		
		that.get = function(fn) {
			stack.push(fn);
		};
		that.put = function(a,b) {
			that.get = function(fn) {
				fn(a,b);
			};
			
			while (stack.length) {
				stack.shift()(a,b);
			}
		};
		return that;
	};
	
	// utilities below
	
	exports.encode = function(num) {
		var ALPHA = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

		return function(i) {
			return i < ALPHA.length ? ALPHA.charAt(i) : exports.encode(Math.floor(i / ALPHA.length)) + ALPHA.charAt(i % ALPHA.length);
		};
	}();

	exports.uuid = function() {
		var inc = 0;		

		return function() {
			var uuid = '';

			for (var i = 0; i < 36; i++) {
				uuid += exports.encode(Math.floor(Math.random() * 62));
			}
			return uuid + '-' + exports.encode(inc++);			
		};
	}();
	
	exports.gensym = function() {
		var s = 0;
		
		return function() {
			return 's'+(s++);
		};
	}();

	exports.format = function (str, col) {
		col = typeof col === 'object' ? col : Array.prototype.slice.call(arguments, 1);

		return str.replace(/\{([^{}]+)\}/gm, function () {
			return col[arguments[1]] === undefined ? arguments[0] : col[arguments[1]];
		});
	};
	
	exports.log = function(str) {
		str = ''+str;
		
		var format = exports.format.apply(exports, arguments);
		
		if (typeof window !== 'undefined' && !window.console) {
			return;
		}
		console.log(format);
	};

}(typeof window === 'undefined' ? exports : module('common')));