var common = require('common');
var http = require('http');
var https = require('https');

var createRouter = function(options) {
	options = options || {};
	
	// argument already has a router
	if (options.router) {
		return options.router;
	}
	// argument is a http server
	if (typeof options.listen === 'function') {
		return createRouter({server:options, autoclose:false}); // lets not autoclose lazy creations of the router
	}
	// valid options are:
	// options.autoclose = false; defaults to true
	// options.server = httpServer;
	// options.key = ssl-key; for https 
	// options.crt = ssl-crt; for https
		
	var that = {};

	var server = options.server || (options.key ? https.createServer({key:options.key,cert:options.cert}) : http.createServer());

	that.autoclose = options.autoclose !== false;
	that.server = server;
	that.router = server.router = that;

	var fallbacks = {};
	var methods = {request:{},'delete':{},get:{},head:{},post:{},put:{},upgrade:{}};

	var add = function(method) {
		return function(regexp, replace, fn) {
			if (arguments.length === 1) {
				fallbacks[method] = regexp;
			}
			if (arguments.length === 2) {
				methods[method][''+regexp] = {regexp:regexp, fn:replace, replace:undefined};
			}
			if (arguments.length === 3) {
				methods[method][''+regexp] = {regexp:regexp, fn:fn, replace:replace};
			}
		};
	};
	var find = function(method, request) {
		method = method.toLowerCase();
		
		if (method !== 'request') {
			var fn = find('request', request);
			
			if (fn) {
				return fn;
			}
		}
		var handlers = methods[method];

		request.realUrl = request.url;

		for (var i in handlers) {
			var h = handlers[i];
			
			var matches = request.url.match(h.regexp);
			
			if (typeof h.regexp === 'string' ? h.regexp === request.url : matches) {
				request.matches = matches;		
				if (h.replace !== undefined) {
					request.url = request.url.replace(h.regexp, h.replace);
				}
				return h.fn;
			}
		}

		return fallbacks[method];
	};
	var route = function(request, response) {
		if (request.method === 'OPTIONS') {
			response.writeHead(200, {
				'access-control-allow-origin': '*',
				'access-control-allow-methods': 'PUT, POST, GET, OPTIONS',
				'access-control-allow-headers': 'Content-Type'					
			});
			response.end();
			return;
		}
		
		var fn = find(request.method, request);
		
		if (fn) {
			fn(request, response);
			return;
		}		
		if (!that.autoclose) {
			return;
		}
		if (request.method === 'POST' || request.method === 'PUT') {
			request.connection.destroy(); //lets not read any data we dont want
			return;
		}
		response.writeHead(404);
		response.end();
	};

	server.on('request', route);
	server.on('upgrade', function(request, connection, head) {
		var fn = find('upgrade', request);
		
		if (fn) {
			fn(request, connection, head);
			return;
		}
		if (!that.autoclose) {
			return;
		}
		connection.destroy();
	});

	for (var i in methods) {
		that[i] = add(i);
	}
	
	that.route = route;
	that.close = function() {
		server.close();
	};
	that.remove = function(method, regexp) {
		if (!regexp) {
			delete fallbacks[method];
			return;
		} 
		delete methods[method][regexp+''];
	};
	that.listen = function() {
		server.listen.apply(server, arguments);
	};
	
	return that;
};
exports.createRouter = createRouter;

exports.onfilerequest = function(dir, options) {
	var fs = require('fs');
	var path = require('path');
	var mimes = require('mimes');

	options = options || {};
	// TODO: add cache option

	return function(request, response) {
		var url = request.url.split('?')[0];
		
		url = path.normalize(url);
		
		// security check
		if (/\/\.\.\//.test(url)) {
			response.writeHead(404);
			response.end();
			return;
		}
		
		url = path.join(dir, url);

		fs.readFile(url, function(err, buffer) {
			if (err) {
				response.writeHead(404);
				response.end();
				return;
			}
			response.writeHead(options.status || 200, {
				'content-type':mimes.resolve(url)
			});
			response.end(buffer);				
		});			
	};
};